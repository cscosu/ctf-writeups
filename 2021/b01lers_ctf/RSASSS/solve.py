import Crypto.Util.number as cun
import shamir

## Part 1


def find_root(ct, e):
    # Binary search for the eth root
    left = 0
    right = ct
    while left < right:
        mid = (left + right) // 2
        x = pow(mid, e)
        if x == ct:
            return mid
        elif x > ct:
            right = mid - 1
        else:
            left = mid + 1

    print("Couldn" "t find cube root")
    return -1


N = 97047969232146954924046774696075865737213640317155598548487427318856539382020276352271195838803309131457220036648459752540841036128924236048549721616504194211254524734004891263525843844420125276708561088067354907535207032583787127753999797298443939923156682493665024043791390402297820623248479854569162947726288476231132227245848115115422145148336574070067423431126845531640957633685686645225126825334581913963565723039133863796718136412375397839670960352036239720850084055826265202851425314018360795995897013762969921609482109602561498180630710515820313694959690818241359973185843521836735260581693346819233041430373151
e = 3
ct = 6008114574778435343952018711942729034975412246009252210018599456513617537698072592002032569492841831205939130493750693989597182551192638274353912519544475581613764788829782577570885595737170709653047941339954488766683093231757625

pt1 = find_root(ct, e)
pt1 = cun.long_to_bytes(pt1).decode()
print(pt1)

# Part 2

# Used https://crypto.stackexchange.com/a/81966 but instead of just dividing by
# the GCD divide until lambda and e are coprime

p = 7237005577332262213973186563042994240829374041602535252466099000494570602917
q = 88653318322320212121171535397276679450159832009631056842709712756058489880609
e = 16
ct = 128067909105216284348808993695734979917384615977985008857494038384160720721127262500602107681721675827823420594821881043967947295783995842628815275429540
N = p * q
phi = (p - 1) * (q - 1)

lam = phi // cun.GCD(phi, e)  # phi // 16
lam = lam // cun.GCD(lam, e)  # phi // 8
assert cun.GCD(lam, e) == 1

# Find lam-th roots of unity (i.e. pow(un, lam, N) == 1)
# There are probably better ways to do this but I am lazy
uns = set()
i = 1
while len(uns) < 128:
    un = pow(i, lam, N)
    uns.add(un)
    i += 1

uns = sorted(list(uns))

# Recover plaintexts
d = cun.inverse(e, lam)
first_pt = pow(ct, d, N)
pts = [(un * first_pt) % N for un in uns]

# Pick the correct one
pt2 = None
pts = [hex(pt) for pt in pts]
for pt in pts:
    if "0x28322" in pt:
        pt = int(pt, 16)
        pt2 = cun.long_to_bytes(pt).decode()
        break

assert pt2 != None
print(pt2)

# Part 3

N = 3213876088517980551083924185487283336189331657515992206038949
e = 65537
c = 2941293819923490843589362205798232424837846370982721175905966

# From factordb
p = 1267650600228229401496703205653
q = 2535301200456458802993406410833
assert p * q == N

phi = (p - 1) * (q - 1)
d = cun.inverse(e, phi)
pt3 = pow(c, d, N)
pt3 += 541893472927304311696017462663852715895951883676838007787557872016428 * N
pt3 = cun.long_to_bytes(pt3).decode()
print(pt3)

# ---

a = eval(pt1)
b = eval(pt2)
c = eval(pt3)

res = shamir.recover_secret([a, b, c], prime=cun.getPrime(512))
print(cun.long_to_bytes(res).decode())
